---
feature_id: "F025"
feature_name: "adaptive-concurrency"
title: "Адаптивный Concurrency для массового прогона"
created: "2026-02-25"
author: "AI (Analyst)"
type: "prd"
status: "PRD_READY"
version: 1
mode: "FEATURE"

related_features: [F022, F023, F024]
services: [free-ai-selector-business-api]
requirements_count: 8

pipelines:
  business: true
  data: false
  integration: true
  modified: [batch-processing]
---

# PRD: Адаптивный Concurrency для массового прогона

**Feature ID**: F025
**Версия**: 1.0
**Дата**: 2026-02-25
**Автор**: AI Agent (Аналитик)
**Статус**: Approved

---

## 1. Обзор

### 1.1 Проблема

Массовый прогон LLM-запросов (3686 запросов, 2026-02-24) не адаптирует скорость отправки при росте ошибок. Error rate вырос с 5% до 100% за 3.5 часа — система продолжала слать запросы с постоянной частотой (~16 запросов/мин), ускоряя исчерпание rate limits у оставшихся рабочих провайдеров.

**Деградация по фазам прогона:**

| Фаза | Индексы | Error rate | Причина |
|------|---------|-----------|---------|
| Стабильная | 1-400 | 5-6% | Только HTTP 422 (payload) |
| Переходная | 401-1000 | 21-49% | 422 + 500 начинают расти |
| Деградация | 1001-2400 | 46-91% | Rate limits исчерпаны |
| Полный отказ | 2401-3686 | 91-100% | Все провайдеры отказали |

**Последствия:**
- 2436 из 3686 запросов завершились ошибкой (66%)
- Прогон длился 3ч 45мин, из которых последние ~2ч были бесполезны (error rate > 80%)
- Максимальная непрерывная серия ошибок: 266 запросов подряд

### 1.2 Решение

Реализовать **AdaptiveConcurrency** — компонент для динамического управления параллелизмом в скрипте массового прогона на основе скользящего окна error rate:

```
                    ┌─────────────────┐
                    │  Error Monitor  │
                    │ (скользящее окно│
                    │   50 запросов)  │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              ▼              ▼              ▼
        error < 20%    20-50%        error > 50%
              │              │              │
       concurrency++   без изменений  concurrency--
       (до max)                       (до min=1)
                                      + пауза
```

При высоком error rate система замедляется, давая провайдерам время восстановиться. При низком — ускоряется обратно. Результат: прогон длится дольше, но с существенно меньшим error rate.

### 1.3 Целевая аудитория

| Сегмент | Описание | Потребности |
|---------|----------|-------------|
| Скрипт массового прогона | Пакетная обработка (reclassification, ~3000-10000 запросов) | Максимальный throughput при допустимом error rate (< 20%) |
| Разработчики | Запускают прогоны для тестирования/валидации | Понятные метрики: текущий concurrency, error rate, estimated ETA |
| Операторы | Мониторят прогоны | Автоматическая адаптация без ручного вмешательства |

### 1.4 Ценностное предложение

- Error rate при массовом прогоне снижается с ~66% до ожидаемых < 20%
- Прогон автоматически замедляется вместо каскадного отказа
- Рабочие провайдеры не исчерпывают rate limits из-за чрезмерной нагрузки
- Не требует изменений в Business API — работает на уровне скрипта прогона

---

## 2. Функциональные требования

### 2.1 Core Features (Must Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-001 | Скользящее окно error rate | Мониторить error rate за последние `window_size` (env, default 50) запросов. Считать долю неуспешных. | Тест: 25 ошибок из 50 → error_rate = 0.5. |
| FR-002 | Снижение concurrency при высоком error rate | При error_rate > `high_threshold` (env, default 0.5) снижать concurrency: `current = max(min_concurrency, current // 2)`. | Тест: concurrency=8, error_rate=60% → concurrency=4. |
| FR-003 | Повышение concurrency при низком error rate | При error_rate < `low_threshold` (env, default 0.2) повышать: `current = min(max_concurrency, current + 1)`. | Тест: concurrency=4, error_rate=10% → concurrency=5. |
| FR-004 | Cooldown пауза | При error_rate > high_threshold добавлять паузу `cooldown_seconds` (env, default 5.0) перед каждым запросом. | Тест: при error_rate=70% задержка 5 сек между запросами. |
| FR-005 | Semaphore для управления параллелизмом | Использовать `asyncio.Semaphore` для ограничения одновременных запросов. Пересоздавать при изменении concurrency. | Тест: при concurrency=2 одновременно выполняются максимум 2 запроса. |

### 2.2 Important Features (Should Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-010 | Логирование изменений concurrency | При каждом изменении логировать: old_concurrency, new_concurrency, current_error_rate, window_stats. | В логах: `concurrency_adjusted old=8 new=4 error_rate=0.62 window=50`. |
| FR-011 | Отчёт post-run | По завершении прогона выводить итоговую статистику: total, ok, errors, concurrency_changes, min/max/avg_concurrency. | Отчёт содержит все метрики. |

### 2.3 Nice to Have (Could Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-020 | Early stop | При error_rate > 95% за `stop_window` (default 100) последних запросов — автоматическая остановка прогона с сообщением. | Прогон прерывается с `"early_stop: error_rate=97% over last 100 requests"`. |

---

## 3. User Stories

### US-001: Прогон замедляется вместо падения

**Как** скрипт массового прогона
**Я хочу** автоматически снижать скорость при росте ошибок
**Чтобы** не исчерпать rate limits рабочих провайдеров

**Критерии приёмки:**
- [ ] При error_rate > 50% concurrency снижается вдвое
- [ ] При error_rate < 20% concurrency увеличивается на 1
- [ ] Минимальный concurrency = 1 (не останавливается полностью)

**Связанные требования:** FR-001, FR-002, FR-003, FR-005

### US-002: Прогон восстанавливается после спада ошибок

**Как** скрипт массового прогона
**Я хочу** автоматически ускоряться когда провайдеры восстановились
**Чтобы** не работать медленно всё оставшееся время

**Критерии приёмки:**
- [ ] После снижения до concurrency=2, при восстановлении error_rate < 20% → concurrency растёт обратно до max
- [ ] Рост постепенный: +1 за каждое окно с низким error rate

**Связанные требования:** FR-003, FR-005

### US-003: Понятный отчёт после прогона

**Как** разработчик
**Я хочу** видеть итоговую статистику прогона
**Чтобы** понимать как адаптация повлияла на результат

**Критерии приёмки:**
- [ ] Отчёт содержит: total, ok, errors, error_rate, concurrency_changes, duration
- [ ] Сравнение: ожидаемый error rate без адаптации vs фактический

**Связанные требования:** FR-011

---

## 4. Пайплайны

### 4.0 Тип изменений

| Параметр | Значение |
|----------|----------|
| Режим | FEATURE |
| Затрагиваемые пайплайны | batch-processing (новый компонент) |

### 4.1 Бизнес-пайплайн

**Основной flow массового прогона (изменённый):**

```
[Загрузить batch вопросов]
  → [Инициализировать AdaptiveConcurrency(initial=8)]
    → [Для каждого вопроса]:
       → [ac.acquire()] ← НОВОЕ: ожидание семафора + cooldown при высоком error_rate
         → [POST /api/v1/prompts/process]
           → [ac.record(success=status==200)] ← НОВОЕ: обновление скользящего окна
             → [ac.release()] ← НОВОЕ: освобождение семафора
               → [_adjust() при полном окне] ← НОВОЕ: пересчёт concurrency
    → [Вывести post-run отчёт] ← НОВОЕ (FR-011)
```

### 4.2 Data Pipeline

Не затрагивается. Адаптивный concurrency работает на уровне скрипта прогона, Business API и Data API не меняются.

### 4.3 Интеграционный пайплайн

**Точки интеграции:**

| ID | От | К | Описание |
|----|----|---|-----------|
| INT-001 | Скрипт прогона | AdaptiveConcurrency | Новая зависимость: `acquire()`, `record()`, `release()` |
| INT-002 | Скрипт прогона | Business API | Существующий HTTP вызов POST /process — без изменений |

### 4.4 Влияние на существующие пайплайны

| Пайплайн | Тип изменения | Затрагиваемые этапы | Обратная совместимость |
|----------|---------------|---------------------|------------------------|
| batch-processing | add | Новый компонент AdaptiveConcurrency | Да — скрипт прогона получает опциональный флаг `--adaptive` |
| Business API | нет изменений | — | Да |
| Data API | нет изменений | — | Да |

**Breaking changes:**
- [x] Нет breaking changes — AdaptiveConcurrency опционален (`--adaptive` флаг)

---

## 5. UI/UX требования

Не применимо. CLI-утилита для разработчиков/операторов.

---

## 6. Нефункциональные требования

### 6.1 Производительность

| ID | Метрика | Требование | Измерение |
|----|---------|------------|-----------|
| NF-001 | Error rate при 3000+ запросах | < 20% (вместо текущих 66%) | Прогон с `--adaptive` |
| NF-002 | Overhead адаптации | < 1 мс на запрос (без учёта cooldown пауз) | Профилирование |
| NF-003 | Throughput при стабильных провайдерах | Не ниже ~14 запросов/мин при max concurrency | Прогон без ошибок |

### 6.2 Надёжность

| ID | Метрика | Требование |
|----|---------|------------|
| NF-010 | Обратная совместимость | Прогон без `--adaptive` работает как раньше (фиксированный concurrency) |
| NF-011 | Минимальный concurrency | Никогда не падает ниже 1 (прогон не останавливается) |

### 6.3 Требования к тестированию

#### Unit тесты
- **Требуются**: Да
- **Порог покрытия**: >= 75%
- **Критические модули**: `adaptive_concurrency.py`

#### Сводная таблица

| ID | Тип | Требование | Обязательно |
|----|-----|-----------|-------------|
| TRQ-001 | Unit | error_rate вычисляется корректно | Да |
| TRQ-002 | Unit | concurrency снижается при high error rate | Да |
| TRQ-003 | Unit | concurrency повышается при low error rate | Да |
| TRQ-004 | Unit | concurrency не выходит за min/max bounds | Да |
| TRQ-005 | Unit | cooldown пауза при high error rate | Да |
| TRQ-006 | Unit | post-run отчёт содержит все метрики | Да |
| TRQ-007 | Integration | Прогон 100 запросов с --adaptive vs без | Нет (ручной) |

---

## 7. Технические ограничения

### 7.1 Затрагиваемые файлы

| Файл | Изменение |
|------|-----------|
| `app/application/services/adaptive_concurrency.py` | **Новый файл**: класс AdaptiveConcurrency |
| Скрипт массового прогона (расположение TBD) | Интеграция AdaptiveConcurrency |

### 7.2 Ограничения

- Адаптация реактивная (по факту ошибок), не предиктивная. При резком всплеске ошибок нужно ~50 запросов чтобы заполнить окно и среагировать.
- Пересоздание `asyncio.Semaphore` при смене concurrency может привести к кратковременному всплеску параллельных запросов (пока старые не завершатся).
- Скрипт массового прогона пока не реализован как отдельный файл в проекте (упоминается в docs/api-tests, но нет в `scripts/`). F024 включает создание этого скрипта или утилиты.

---

## 8. Допущения и риски

### 8.1 Допущения

| # | Допущение | Влияние если неверно |
|---|-----------|---------------------|
| 1 | Error rate > 50% означает системную проблему (rate limits, мёртвые провайдеры) | Если кратковременный всплеск — concurrency снизится без нужды. Восстановится через ~50 запросов. |
| 2 | Cooldown 5 сек даёт провайдерам время восстановить rate limit window | Если мало — увеличить через env. |
| 3 | F022 (classify_error fix) и F023 (circuit breaker) снижают базовый error rate до < 30% | Без них адаптивность не спасёт от 8 мёртвых провайдеров. |

### 8.2 Риски

| # | Риск | Вероятность | Влияние | Митигация |
|---|------|-------------|---------|-----------|
| 1 | Прогон растягивается в 5-10 раз из-за постоянного cooldown | Med | Med | Early stop (FR-020) при error_rate > 95%. Smoke-тест провайдеров перед прогоном. |
| 2 | Ложное снижение concurrency при коротком всплеске ошибок | Low | Low | Окно 50 запросов — достаточно для фильтрации шума. |
| 3 | Скрипт прогона не существует как отдельный файл | Med | Low | F024 создаёт утилиту AdaptiveConcurrency. Интеграция с конкретным скриптом — при реализации. |

---

## 9. Открытые вопросы

| # | Вопрос | Статус | Решение |
|---|--------|--------|---------|
| 1 | Где расположить скрипт массового прогона? | Open | Предложение: `scripts/batch_run.py` или `tools/reclassification/`. Уточнить при реализации. |
| 2 | Нужна ли интеграция с Circuit Breaker (F023) на уровне прогона? | Resolved | Нет — CB работает внутри Business API. Прогон видит только HTTP-ответы (200/500). |

---

## 10. Глоссарий

| Термин | Определение |
|--------|-------------|
| Adaptive Concurrency | Динамическое изменение количества параллельных запросов на основе error rate |
| Скользящее окно | Буфер последних N результатов для вычисления текущего error rate |
| Cooldown | Пауза между запросами при высоком error rate |
| Semaphore | Примитив синхронизации, ограничивающий количество одновременных операций |
| Early stop | Автоматическая остановка прогона при критическом error rate |

---

## 11. История изменений

| Версия | Дата | Автор | Изменения |
|--------|------|-------|-----------|
| 1.0 | 2026-02-25 | AI Analyst | Первоначальная версия |

---

## Качественные ворота

### PRD_READY Checklist

- [x] Все секции заполнены
- [x] Требования имеют уникальные ID (FR-001-FR-020, NF-001-NF-011, TRQ-001-TRQ-007)
- [x] Критерии приёмки определены для каждого требования
- [x] User stories связаны с требованиями
- [x] Бизнес-пайплайн описан (flow массового прогона)
- [x] Data Pipeline описан (не затрагивается)
- [x] Интеграционный пайплайн описан (INT-001, INT-002)
- [x] Раздел "Влияние на существующие пайплайны" заполнен
- [x] Нет блокирующих открытых вопросов
- [x] Риски идентифицированы и имеют план митигации
