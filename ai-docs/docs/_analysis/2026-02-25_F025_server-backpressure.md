---
feature_id: "F025"
feature_name: "server-backpressure"
title: "Серверная защита от перегрузки: HTTP 429/503 + backpressure"
created: "2026-02-25"
author: "AI (Analyst)"
type: "prd"
status: "PRD_READY"
version: 2
mode: "FEATURE"

related_features: [F022, F023, F024]
services: [free-ai-selector-business-api]
requirements_count: 10

pipelines:
  business: true
  data: false
  integration: true
  modified: [prompt-processing]
---

# PRD: Серверная защита от перегрузки — HTTP 429/503 + Backpressure

**Feature ID**: F025
**Версия**: 2.0 (полная переформулировка)
**Дата**: 2026-02-25
**Автор**: AI Agent (Аналитик)
**Статус**: Approved

---

## 1. Обзор

### 1.1 Проблема

Business API **не сообщает клиентам** о перегрузке провайдеров. При массовом прогоне (3686 запросов, 2026-02-24) error rate вырос с 5% до 100%, но API продолжал отвечать HTTP 500 на каждый запрос — клиент не мог отличить "провайдеры заняты, подожди" от "запрос невалиден" от "сервер сломался".

**Текущее поведение — все ошибки = HTTP 500:**

| Ситуация | Правильный HTTP код | Фактический код |
|----------|-------------------|-----------------|
| Все провайдеры вернули 429 (rate limit) | **429** + Retry-After | 500 |
| Все провайдеры мертвы (CB open) | **503** + Retry-After | 500 |
| Нет активных моделей в БД | **503** | 500 |
| Нет API-ключей в env | **503** | 500 |
| Запрос обработан успешно | 200 | 200 |

**Дополнительные проблемы:**
- slowapi rate limiter (`100 req/60s`) защищает только `/api`, но НЕ защищает `/api/v1/prompts/process`
- Заголовки `X-RateLimit-*` отключены (`headers_enabled=False` в slowapi)
- Формат ошибок несогласован: `{"error": "..."}` vs `{"detail": "..."}`

**Последствия:**
- Внешние клиенты (скрипты, боты, UI) не могут реализовать backoff — нет информации когда повторять
- Массовый прогон шлёт запросы в мёртвую стену вместо паузы
- Нет стандартного HTTP-механизма для замедления клиентов

### 1.2 Решение

Добавить в Business API **серверную защиту от перегрузки** по стандартам HTTP (RFC 6585, RFC 7231):

```
Клиент → POST /process → Business API
                              │
                ┌─────────────┼─────────────────┐
                ▼             ▼                 ▼
          Провайдеры ОК   Rate limited     Все мертвы
                │          (429 от LLM)    (CB open)
                ▼             ▼                 ▼
           HTTP 200      HTTP 429           HTTP 503
           + ответ       + Retry-After:60   + Retry-After:30
           + X-RateLimit-*  + X-RateLimit-*    + X-RateLimit-*
```

Любой HTTP-клиент (curl, httpx, aiohttp, requests) понимает 429 и `Retry-After` из коробки — **внешние скрипты автоматически замедлятся** без кастомной логики.

### 1.3 Целевая аудитория

| Сегмент | Описание | Что получает |
|---------|----------|-------------|
| Внешние скрипты | Массовые прогоны с любого сервера | HTTP 429 + Retry-After → автоматический backoff |
| Telegram Bot | aiogram клиент Business API | Корректные HTTP-коды для отображения ошибок |
| Web UI | Браузерный клиент | Понятные сообщения "сервис перегружен, повторите через N сек" |
| Мониторинг | Grafana/Prometheus | Раздельные метрики 429 vs 503 vs 500 |

### 1.4 Ценностное предложение

- Любой внешний клиент автоматически замедляется по стандартному HTTP-механизму
- Не требует изменений в клиентских скриптах — стандартные HTTP-коды
- Разделение ошибок: "подожди" (429) vs "недоступен" (503) vs "баг" (500)
- Rate limit заголовки показывают оставшуюся квоту в каждом ответе

---

## 2. Функциональные требования

### 2.1 Core Features (Must Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-001 | HTTP 429 при исчерпании rate limits | Если все провайдеры вернули RateLimitError → ответить клиенту HTTP 429 с заголовком `Retry-After`. Значение `Retry-After` = минимальный `retry_after_seconds` из ошибок провайдеров (default: 60 сек). | Тест: mock все провайдеры бросают RateLimitError(retry_after=30) → клиент получает HTTP 429 + `Retry-After: 30`. |
| FR-002 | HTTP 503 при недоступности сервиса | Если нет активных моделей, нет API-ключей, или все провайдеры в состоянии Circuit Breaker OPEN → ответить HTTP 503 с заголовком `Retry-After` (env `SERVICE_UNAVAILABLE_RETRY_AFTER`, default: 30 сек). | Тест: 0 моделей → HTTP 503 + `Retry-After: 30`. |
| FR-003 | Заголовки X-RateLimit-* | В каждом HTTP-ответе (200, 429, 503) добавлять заголовки: `X-RateLimit-Limit` (лимит за окно), `X-RateLimit-Remaining` (осталось), `X-RateLimit-Reset` (UNIX timestamp сброса). | Тест: после 5 запросов `X-RateLimit-Remaining` уменьшился на 5. |
| FR-004 | Rate limiter на /process | Применить slowapi `@limiter.limit` к эндпоинту `POST /api/v1/prompts/process` с настраиваемым лимитом (env `PROCESS_RATE_LIMIT`, default: `"100/minute"`). | Тест: 101-й запрос за минуту → HTTP 429. |
| FR-005 | Включить headers_enabled в slowapi | Включить `headers_enabled=True` в `Limiter()` чтобы slowapi автоматически инжектил заголовки `X-RateLimit-*` и `Retry-After` в каждый ответ. | Тест: успешный HTTP 200 содержит `X-RateLimit-Remaining`. |

### 2.2 Important Features (Should Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-010 | Дифференциация ошибок в response body | Вместо одинакового `{"detail": "Failed to process prompt..."}` возвращать структурированный JSON: `{"error": "<type>", "message": "<human-readable>", "retry_after": <seconds or null>}`. | Тест: HTTP 429 body содержит `"error": "rate_limited"`, `"retry_after": 60`. |
| FR-011 | Логирование backpressure событий | При возврате HTTP 429/503 логировать: event, причину, retry_after, client_ip. | В логах: `backpressure_applied status=429 reason=all_rate_limited retry_after=60`. |

### 2.3 Nice to Have (Could Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-020 | Provider availability в заголовке | Добавить заголовок `X-Providers-Available: 3/14` показывающий сколько провайдеров доступно. | Тест: 3 из 14 провайдеров доступны → `X-Providers-Available: 3/14`. |

---

## 3. User Stories

### US-001: Внешний скрипт автоматически замедляется

**Как** внешний скрипт массового прогона (на любом сервере, любом языке)
**Я хочу** получать HTTP 429 + Retry-After когда провайдеры перегружены
**Чтобы** автоматически делать паузу и не усугублять перегрузку

**Критерии приёмки:**
- [ ] При исчерпании rate limits всех провайдеров → HTTP 429 + `Retry-After: N`
- [ ] Стандартный httpx/aiohttp/requests клиент может обработать 429 без кастомного кода
- [ ] После паузы N секунд повторный запрос имеет шанс на успех

**Связанные требования:** FR-001, FR-003, FR-005

### US-002: Клиент знает что сервис временно недоступен

**Как** любой клиент (бот, UI, скрипт)
**Я хочу** получать HTTP 503 когда сервис не может обработать запрос
**Чтобы** понимать что это временная проблема и знать когда повторить

**Критерии приёмки:**
- [ ] Нет моделей → HTTP 503 (вместо 500)
- [ ] Все CB open → HTTP 503 (вместо 500)
- [ ] Нет API-ключей → HTTP 503 (вместо 500)
- [ ] Заголовок `Retry-After` подсказывает когда повторить

**Связанные требования:** FR-002, FR-003

### US-003: Мониторинг различает типы ошибок

**Как** оператор
**Я хочу** видеть раздельные метрики HTTP 429 vs 503 vs 500
**Чтобы** понимать причину проблем (перегрузка vs недоступность vs баг)

**Критерии приёмки:**
- [ ] HTTP 429 — провайдеры перегружены (временно)
- [ ] HTTP 503 — сервис недоступен (провайдеры мертвы)
- [ ] HTTP 500 — реальный баг (необработанное исключение)

**Связанные требования:** FR-001, FR-002, FR-010

---

## 4. Пайплайны

### 4.0 Тип изменений

| Параметр | Значение |
|----------|----------|
| Режим | FEATURE |
| Затрагиваемые пайплайны | prompt-processing (Business API) |

### 4.1 Бизнес-пайплайн

**Текущий flow (все ошибки → 500):**

```
POST /process
  → use_case.execute()
    → fallback loop по провайдерам
      → RateLimitError / ServerError / ... → continue
    → Exception("All providers failed")
  → except Exception → HTTP 500  ← ВСЕ ошибки одинаковы
```

**Новый flow (дифференциация ошибок):**

```
POST /process
  → use_case.execute()
    → fallback loop по провайдерам
      → ...
    → AllProvidersRateLimited(retry_after=60)   ← НОВОЕ: типизированное исключение
    → ServiceUnavailable("No active models")     ← НОВОЕ: типизированное исключение
    → Exception("unexpected error")              ← Только реальные баги
  → except AllProvidersRateLimited → HTTP 429 + Retry-After  ← НОВОЕ
  → except ServiceUnavailable → HTTP 503 + Retry-After       ← НОВОЕ
  → except Exception → HTTP 500                               ← Только баги
```

### 4.2 Data Pipeline

Не затрагивается.

### 4.3 Интеграционный пайплайн

**Точки интеграции:**

| ID | От | К | Описание |
|----|----|---|-----------|
| INT-001 | prompts.py | process_prompt.py | Новые исключения: AllProvidersRateLimited, ServiceUnavailable |
| INT-002 | main.py | slowapi | Включение headers_enabled, rate limit на /process |
| INT-003 | prompts.py | Клиенты | Новые HTTP-коды 429, 503 + заголовки |

### 4.4 Влияние на существующие пайплайны

| Пайплайн | Тип изменения | Затрагиваемые этапы | Обратная совместимость |
|----------|---------------|---------------------|------------------------|
| prompt-processing | modify | HTTP-коды ответов | Частично — клиенты, ожидающие только 200/500, получат 429/503 |
| Data API | нет изменений | — | Да |
| Telegram Bot | необходимо обновить | Обработка HTTP 429/503 | Да (FastAPI fallback → 500 если не обработан) |

**Breaking changes:**
- [ ] Клиенты, которые ловят только HTTP 500 как ошибку, не увидят 429/503 как ошибку. Однако это **правильное** поведение по RFC — 429/503 являются стандартными ошибками, и любой HTTP-клиент обрабатывает 4xx/5xx как ошибки.

---

## 5. UI/UX требования

Не применимо напрямую. Telegram Bot и Web UI должны обрабатывать новые HTTP-коды:

| HTTP код | Сообщение пользователю |
|----------|----------------------|
| 429 | "AI-провайдеры перегружены. Повторите через N секунд." |
| 503 | "Сервис временно недоступен. Попробуйте позже." |

---

## 6. Нефункциональные требования

### 6.1 Производительность

| ID | Метрика | Требование | Измерение |
|----|---------|------------|-----------|
| NF-001 | Overhead заголовков | < 1 мс на запрос | Профилирование middleware |
| NF-002 | Rate limit вычисление | < 1 мс (slowapi in-memory) | Профилирование |

### 6.2 Надёжность

| ID | Метрика | Требование |
|----|---------|------------|
| NF-010 | Обратная совместимость | HTTP 200 ответы не меняют формат body |
| NF-011 | Fallback | При ошибке в middleware → fallback на HTTP 500 (не ломает API) |

### 6.3 Требования к тестированию

#### Unit тесты
- **Требуются**: Да
- **Порог покрытия**: >= 75%
- **Критические модули**: `prompts.py` (exception handlers), `process_prompt.py` (новые исключения)

#### Сводная таблица

| ID | Тип | Требование | Обязательно |
|----|-----|-----------|-------------|
| TRQ-001 | Unit | Все провайдеры RateLimited → HTTP 429 + Retry-After | Да |
| TRQ-002 | Unit | Нет моделей → HTTP 503 + Retry-After | Да |
| TRQ-003 | Unit | Все CB open → HTTP 503 + Retry-After | Да |
| TRQ-004 | Unit | Нет API-ключей → HTTP 503 | Да |
| TRQ-005 | Unit | Успешный запрос → HTTP 200 + X-RateLimit-* | Да |
| TRQ-006 | Unit | 101-й запрос за минуту → HTTP 429 (slowapi) | Да |
| TRQ-007 | Unit | Структурированный error body (FR-010) | Да |

---

## 7. Технические ограничения

### 7.1 Затрагиваемые файлы

| Файл | Изменение |
|------|-----------|
| `app/domain/exceptions.py` | Новые исключения: `AllProvidersRateLimited`, `ServiceUnavailable` |
| `app/application/use_cases/process_prompt.py` | Бросать типизированные исключения вместо общего `Exception` |
| `app/api/v1/prompts.py` | Exception handlers для 429/503, заголовки |
| `app/main.py` | `headers_enabled=True`, rate limit на `/process` |
| `tests/unit/test_process_prompt_use_case.py` | Тесты новых исключений |

### 7.2 Ограничения

- `Retry-After` при 429 основан на `retry_after_seconds` от провайдеров — если провайдер не возвращает этот заголовок, используется default (60 сек)
- slowapi использует in-memory хранилище — при рестарте контейнера счётчики сбрасываются
- `X-RateLimit-*` показывают лимит slowapi (клиентский rate limit), а не лимит LLM-провайдеров

---

## 8. Допущения и риски

### 8.1 Допущения

| # | Допущение | Влияние если неверно |
|---|-----------|---------------------|
| 1 | Внешние клиенты обрабатывают HTTP 429 стандартно (pause + retry) | Клиенты без retry-логики получат ошибку вместо результата. Но это их ответственность — API выполнил свою часть. |
| 2 | Telegram Bot и Web UI будут обновлены для обработки 429/503 | Если нет — они получат ошибку вместо user-friendly сообщения. Можно добавить в отдельной задаче. |
| 3 | `retry_after_seconds` из RateLimitError содержит адекватное значение | Если нет — используется default 60 сек. F022 уже парсит заголовок Retry-After от провайдеров. |

### 8.2 Риски

| # | Риск | Вероятность | Влияние | Митигация |
|---|------|-------------|---------|-----------|
| 1 | Telegram Bot падает на неожиданный HTTP 429/503 | Med | Med | Bot уже должен обрабатывать HTTP ошибки. Добавить обработку в отдельной задаче если нужно. |
| 2 | slowapi rate limit слишком строгий/мягкий | Low | Low | Конфигурируется через env `PROCESS_RATE_LIMIT`. |
| 3 | Определение "все провайдеры rate limited" неточно при смешанных ошибках | Med | Low | Если хотя бы один провайдер вернул не-RateLimit ошибку → HTTP 500 (как сейчас). HTTP 429 только если ВСЕ ошибки = RateLimit. |

---

## 9. Открытые вопросы

| # | Вопрос | Статус | Решение |
|---|--------|--------|---------|
| 1 | Нужно ли обновлять Telegram Bot для обработки 429/503? | Resolved | Нет — отдельная задача. Bot сейчас показывает generic ошибку, продолжит работать. |
| 2 | Как определить что "все провайдеры rate limited"? | Resolved | Собирать типы ошибок в fallback loop. Если все ошибки = RateLimitError → бросить AllProvidersRateLimited. |

---

## 10. Глоссарий

| Термин | Определение |
|--------|-------------|
| Backpressure | Механизм сигнализации серверу клиенту "замедлись" через стандартные HTTP-коды |
| Retry-After | HTTP-заголовок (RFC 7231) указывающий клиенту сколько секунд ждать перед повтором |
| X-RateLimit-* | Де-факто стандартные заголовки показывающие лимит, остаток и время сброса |
| HTTP 429 | Too Many Requests (RFC 6585) — клиент превысил rate limit или провайдеры перегружены |
| HTTP 503 | Service Unavailable (RFC 7231) — сервис временно недоступен |

---

## 11. История изменений

| Версия | Дата | Автор | Изменения |
|--------|------|-------|-----------|
| 1.0 | 2026-02-25 | AI Analyst | Первоначальная версия (клиентский AdaptiveConcurrency) |
| 2.0 | 2026-02-25 | AI Analyst | Полная переформулировка: серверная защита HTTP 429/503 + backpressure |

---

## Качественные ворота

### PRD_READY Checklist

- [x] Все секции заполнены
- [x] Требования имеют уникальные ID (FR-001-FR-020, NF-001-NF-011, TRQ-001-TRQ-007)
- [x] Критерии приёмки определены для каждого требования
- [x] User stories связаны с требованиями
- [x] Бизнес-пайплайн описан (текущий flow vs новый flow)
- [x] Data Pipeline описан (не затрагивается)
- [x] Интеграционный пайплайн описан (INT-001..INT-003)
- [x] Раздел "Влияние на существующие пайплайны" заполнен
- [x] Нет блокирующих открытых вопросов
- [x] Риски идентифицированы и имеют план митигации
