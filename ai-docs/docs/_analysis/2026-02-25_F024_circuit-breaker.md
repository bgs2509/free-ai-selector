---
feature_id: "F024"
feature_name: "circuit-breaker"
title: "Circuit Breaker для AI-провайдеров"
created: "2026-02-25"
author: "AI (Analyst)"
type: "prd"
status: "PRD_READY"
version: 1
mode: "FEATURE"

related_features: [F022, F023, F012]
services: [free-ai-selector-business-api]
requirements_count: 8

pipelines:
  business: true
  data: false
  integration: true
  modified: [provider-failover, process-prompt]
---

# PRD: Circuit Breaker для AI-провайдеров

**Feature ID**: F024
**Версия**: 1.0
**Дата**: 2026-02-25
**Автор**: AI Agent (Аналитик)
**Статус**: Approved

---

## 1. Обзор

### 1.1 Проблема

При массовом прогоне (3686 запросов, 2026-02-24) зафиксирован каскадный отказ: error rate вырос с 5% до 100% за 3.5 часа. 8 из 13 провайдеров возвращали постоянные ошибки (401/402/403/404), но система **продолжала обращаться к ним в каждом запросе**.

Текущий механизм cooldown через Data API (`set_availability`) работает только для RateLimitError (429) и требует HTTP-запроса к базе для проверки доступности. Для остальных ошибок нет механизма быстрого исключения провайдера.

**Последствия:**
- Каждый запрос тратит ~4.5 сек на перебор мёртвых провайдеров (14 526 бесполезных вызовов Scaleway за 48ч)
- Максимальная непрерывная серия ошибок: 266 запросов подряд (индексы 3202-3467)
- Средняя латентность ошибочных запросов: 4 591 мс vs 3 236 мс для всех

### 1.2 Решение

Реализовать **in-memory Circuit Breaker** с тремя состояниями для каждого провайдера:

```
CLOSED (рабочий) ──[N ошибок подряд]──▶ OPEN (заблокирован)
                                              │
                                     [recovery_timeout]
                                              ▼
                                        HALF-OPEN (1 пробный)
                                        ╱            ╲
                                   успех              ошибка
                                     ▼                  ▼
                                  CLOSED              OPEN
```

Circuit Breaker работает **в памяти процесса** — без обращений к Data API для проверки состояния. Это даёт мгновенный пропуск нерабочих провайдеров (< 1 мс vs текущие ~500 мс на HTTP-вызов + таймаут провайдера).

### 1.3 Целевая аудитория

| Сегмент | Описание | Потребности |
|---------|----------|-------------|
| Пользователи Telegram-бота | Отправляют промпты через бот | Быстрый ответ — не ждать перебора мёртвых провайдеров |
| Скрипт массового прогона | Пакетная обработка (reclassification) | Минимальная латентность на ошибочных запросах |
| Операторы | Мониторят здоровье системы | Наблюдаемость: какие провайдеры в OPEN/HALF-OPEN |

### 1.4 Ценностное предложение

- Латентность failover снижается с ~4.5 сек до < 100 мс при 8 мёртвых провайдерах
- Провайдеры автоматически восстанавливаются через пробный запрос (HALF-OPEN) без ручного вмешательства
- Не требует изменений в Data API или PostgreSQL

---

## 2. Функциональные требования

### 2.1 Core Features (Must Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-001 | Три состояния CB | Реализовать state machine: CLOSED → OPEN → HALF-OPEN → CLOSED. В CLOSED — все запросы проходят. В OPEN — все блокируются. В HALF-OPEN — один пробный запрос. | Unit-тест: переходы между состояниями корректны. |
| FR-002 | Failure threshold | После `failure_threshold` (env, default 5) ошибок подряд провайдер переходит в OPEN. Счётчик сбрасывается при успехе. | Тест: 5 ошибок подряд → `is_available()` возвращает False. |
| FR-003 | Recovery timeout | Через `recovery_timeout` (env, default 60) секунд после последней ошибки провайдер переходит из OPEN в HALF-OPEN. | Тест: через 60 сек `is_available()` возвращает True (пробный запрос). |
| FR-004 | Интеграция в fallback loop | В `ProcessPromptUseCase.execute()` перед вызовом провайдера проверять `circuit_breaker.is_available(provider_name)`. Если False — пропустить провайдера (`continue`). | Тест: провайдер в OPEN пропускается, вызывается следующий. |
| FR-005 | Запись результатов | После успешного запроса вызывать `record_success(provider)`, после ошибки — `record_failure(provider)`. | Тест: 5 failures → OPEN, затем success в HALF-OPEN → CLOSED. |

### 2.2 Important Features (Should Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-010 | Логирование переходов | При смене состояния логировать через structlog: `circuit_state_changed`, provider, old_state, new_state. | В логах видны переходы: `circuit_state_changed provider=Groq old=CLOSED new=OPEN`. |
| FR-011 | Метод get_status | Метод `get_all_statuses() → dict[str, CircuitState]` для диагностики и мониторинга. | Вызов возвращает `{"Groq": "CLOSED", "Scaleway": "OPEN", ...}`. |

### 2.3 Nice to Have (Could Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-020 | Ускоренное открытие для permanent errors | При AuthenticationError или ValidationError (402/404) переходить в OPEN сразу после 1 ошибки (вместо 5). | Тест: один 403 → OPEN немедленно. |

---

## 3. User Stories

### US-001: Мгновенный пропуск нерабочего провайдера

**Как** пользователь Telegram-бота
**Я хочу** получить ответ от рабочего провайдера за < 5 секунд
**Чтобы** не ждать перебора 8 нерабочих провайдеров

**Критерии приёмки:**
- [ ] Провайдер в OPEN пропускается за < 1 мс
- [ ] Первый рабочий провайдер вызывается без задержки
- [ ] В логах видно `circuit_open_skip provider=Scaleway`

**Связанные требования:** FR-001, FR-002, FR-004

### US-002: Автоматическое восстановление провайдера

**Как** оператор системы
**Я хочу** чтобы провайдер автоматически восстанавливался после ремонта
**Чтобы** не перезапускать приложение вручную

**Критерии приёмки:**
- [ ] Через 60 сек после OPEN → HALF-OPEN (1 пробный запрос)
- [ ] При успехе пробного → CLOSED (провайдер полностью восстановлен)
- [ ] При неудаче пробного → OPEN (ещё 60 сек)

**Связанные требования:** FR-001, FR-003, FR-005

### US-003: Мониторинг состояния CB

**Как** оператор системы
**Я хочу** видеть текущие состояния circuit breaker всех провайдеров
**Чтобы** понимать какие провайдеры заблокированы

**Критерии приёмки:**
- [ ] Доступен метод `get_all_statuses()` для интроспекции
- [ ] В логах фиксируются все переходы между состояниями

**Связанные требования:** FR-010, FR-011

---

## 4. Пайплайны

### 4.0 Тип изменений

| Параметр | Значение |
|----------|----------|
| Режим | FEATURE |
| Затрагиваемые пайплайны | provider-failover, process-prompt |

### 4.1 Бизнес-пайплайн

**Основной flow (изменённый):**

```
[Запрос от клиента]
  → [Получить модели из Data API]
    → [Failover loop по моделям]:
       → [circuit_breaker.is_available(provider)?] ← НОВОЕ (FR-004)
         → Нет: skip, continue → следующая модель
         → Да: [generate_with_retry()]
           → Успех: record_success() ← НОВОЕ (FR-005)
           → Ошибка: record_failure() + classify_error() ← НОВОЕ (FR-005)
             → [Следующая модель]
       → [Все модели исчерпаны → HTTP 500]
```

**Состояния circuit breaker:**

| Состояние | Описание | Переходы |
|-----------|----------|----------|
| CLOSED | Провайдер работает, все запросы проходят | → OPEN (при N ошибок подряд) |
| OPEN | Провайдер заблокирован, запросы не отправляются | → HALF-OPEN (через recovery_timeout) |
| HALF-OPEN | Пробный режим, 1 запрос разрешён | → CLOSED (при успехе) / → OPEN (при ошибке) |

### 4.2 Data Pipeline

Не затрагивается. Circuit breaker работает in-memory, без обращений к Data API для хранения состояния.

### 4.3 Интеграционный пайплайн

**Точки интеграции (изменённые):**

| ID | От | К | Изменение |
|----|----|---|-----------|
| INT-001 | ProcessPromptUseCase | CircuitBreakerManager | Новая зависимость: проверка `is_available()` перед вызовом провайдера |
| INT-002 | ProcessPromptUseCase | CircuitBreakerManager | Запись `record_success()` / `record_failure()` после вызова |

### 4.4 Влияние на существующие пайплайны

| Пайплайн | Тип изменения | Затрагиваемые этапы | Обратная совместимость |
|----------|---------------|---------------------|------------------------|
| provider-failover | modify | fallback loop в execute() | Да — CB добавляет фильтр перед вызовом, не меняет логику вызова |
| retry-service | нет изменений | — | Да |
| error-classification | нет изменений | — | Да |

**Breaking changes:**
- [x] Нет breaking changes для внешнего API (HTTP-контракты не меняются)
- [x] Внутренний: добавляется `CircuitBreakerManager` singleton — не ломает существующий код

---

## 5. UI/UX требования

Не применимо. Изменения внутренние (backend-only).

---

## 6. Нефункциональные требования

### 6.1 Производительность

| ID | Метрика | Требование | Измерение |
|----|---------|------------|-----------|
| NF-001 | Overhead CB проверки | < 0.1 мс на вызов `is_available()` | Профилирование |
| NF-002 | Память на CB state | < 1 KB на провайдера (14 провайдеров = < 14 KB) | `sys.getsizeof()` |
| NF-003 | Латентность запроса при 8 OPEN | < 2 сек (вместо текущих ~4.5 сек) | Prod-метрики |

### 6.2 Надёжность

| ID | Метрика | Требование |
|----|---------|------------|
| NF-010 | Обратная совместимость API | HTTP-контракт `/api/v1/prompts/process` не меняется |
| NF-011 | Потеря state при рестарте | Допустимо — CB восстанавливает состояние за первые несколько запросов |
| NF-012 | Единственный worker | CB in-memory не шарится между uvicorn workers (допустимо для 1 worker) |

### 6.3 Требования к тестированию

#### Smoke тесты (ОБЯЗАТЕЛЬНО)
- [x] Health check отвечает 200
- [x] POST /api/v1/prompts/process → ответ (200 или 500 если все провайдеры недоступны)

#### Unit тесты
- **Требуются**: Да
- **Порог покрытия**: >= 75%
- **Критические модули**: `circuit_breaker.py`, `process_prompt.py`

#### Сводная таблица

| ID | Тип | Требование | Обязательно |
|----|-----|-----------|-------------|
| TRQ-001 | Unit | CLOSED → OPEN после N failures | Да |
| TRQ-002 | Unit | OPEN → HALF-OPEN после recovery_timeout | Да |
| TRQ-003 | Unit | HALF-OPEN → CLOSED после success | Да |
| TRQ-004 | Unit | HALF-OPEN → OPEN после failure | Да |
| TRQ-005 | Unit | is_available() возвращает False в OPEN | Да |
| TRQ-006 | Unit | record_success() сбрасывает failure_count | Да |
| TRQ-007 | Unit | Интеграция в fallback loop — OPEN skip | Да |
| TRQ-008 | Smoke | Health check → 200 | Да |

---

## 7. Технические ограничения

### 7.1 Затрагиваемые файлы

| Файл | Изменение |
|------|-----------|
| `app/application/services/circuit_breaker.py` | **Новый файл**: CircuitBreakerManager, CircuitState, ProviderCircuit |
| `app/application/use_cases/process_prompt.py` | Интеграция CB в fallback loop (строки ~176-210) |

### 7.2 Ограничения

- In-memory state не шарится между uvicorn workers. При нескольких workers каждый имеет свой CB. Для одного worker (текущая конфигурация) — не проблема.
- При рестарте процесса CB state теряется. Восстановление происходит за первые запросы (~5 запросов на провайдер для детекции). Это допустимо.
- CB не заменяет cooldown через Data API для RateLimitError — они работают параллельно.

---

## 8. Допущения и риски

### 8.1 Допущения

| # | Допущение | Влияние если неверно |
|---|-----------|---------------------|
| 1 | Один uvicorn worker на production | Если > 1 worker — каждый имеет свой CB. Не критично, но менее эффективно. |
| 2 | Ошибки 401/402/403/404 — постоянные (F022 классифицирует их корректно) | CB сработает некорректно без F022. F023 зависит от F022. |
| 3 | 60 секунд recovery_timeout достаточно для восстановления | Если мало — увеличить через env `CB_RECOVERY_TIMEOUT`. |

### 8.2 Риски

| # | Риск | Вероятность | Влияние | Митигация |
|---|------|-------------|---------|-----------|
| 1 | Провайдер заблокирован CB, но уже починен | Low | Low | HALF-OPEN через 60 сек пробует 1 запрос |
| 2 | Все провайдеры в OPEN → гарантированный 500 | Med | Med | Логировать `all_circuits_open`; recovery_timeout возвращает провайдеров |
| 3 | Ложноположительное открытие при кратковременных 5xx | Low | Low | threshold=5 подряд — нужна устойчивая серия, не единичная ошибка |

---

## 9. Открытые вопросы

| # | Вопрос | Статус | Решение |
|---|--------|--------|---------|
| 1 | Нужен ли HTTP-endpoint для просмотра CB состояний? | Resolved | Нет в MVP. Достаточно логов и метода `get_all_statuses()`. |
| 2 | Разделять threshold для разных типов ошибок (permanent vs transient)? | Resolved | Опционально (FR-020). В базовой реализации единый threshold. |

---

## 10. Глоссарий

| Термин | Определение |
|--------|-------------|
| Circuit Breaker (CB) | Паттерн отказоустойчивости: временная изоляция нерабочего компонента |
| CLOSED | Нормальное состояние CB — запросы проходят |
| OPEN | Провайдер заблокирован — запросы не отправляются |
| HALF-OPEN | Пробное состояние — 1 запрос для проверки восстановления |
| failure_threshold | Количество ошибок подряд для перехода CLOSED → OPEN |
| recovery_timeout | Время (секунды) до перехода OPEN → HALF-OPEN |

---

## 11. История изменений

| Версия | Дата | Автор | Изменения |
|--------|------|-------|-----------|
| 1.0 | 2026-02-25 | AI Analyst | Первоначальная версия |

---

## Качественные ворота

### PRD_READY Checklist

- [x] Все секции заполнены
- [x] Требования имеют уникальные ID (FR-001-FR-020, NF-001-NF-012, TRQ-001-TRQ-008)
- [x] Критерии приёмки определены для каждого требования
- [x] User stories связаны с требованиями
- [x] Бизнес-пайплайн описан (flow с CB, состояния)
- [x] Data Pipeline описан (не затрагивается)
- [x] Интеграционный пайплайн описан (INT-001, INT-002)
- [x] Раздел "Влияние на существующие пайплайны" заполнен
- [x] Нет блокирующих открытых вопросов
- [x] Риски идентифицированы и имеют план митигации
