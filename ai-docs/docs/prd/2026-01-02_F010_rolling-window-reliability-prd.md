---
feature_id: "F010"
feature_name: "rolling-window-reliability"
title: "Rolling Window Reliability Score"
created: "2026-01-02"
author: "AI (Analyst)"
type: "prd"
status: "PRD_READY"
version: 1
mode: "FEATURE"
related_features: ["F008"]
services: ["free-ai-selector-data-postgres-api", "free-ai-selector-business-api"]
requirements_count: 14
---

# PRD: Rolling Window Reliability Score

**Feature ID**: F010
**Версия**: 1.0
**Дата**: 2026-01-02
**Автор**: AI Agent (Аналитик)
**Статус**: PRD_READY

---

## 1. Обзор

### 1.1 Проблема

Текущая формула расчёта `reliability_score` использует **кумулятивные метрики за всё время**:

```python
success_rate = success_count / request_count  # ВСЕ запросы за ВСЁ время
reliability_score = (success_rate × 0.6) + (speed_score × 0.4)
```

**Это создаёт критическую проблему устаревания данных:**

| Сценарий | Старая модель A | Новая модель B | Результат |
|----------|-----------------|----------------|-----------|
| История | 9900 запросов @ 99% успех | 20 запросов @ 95% успех | — |
| Последние 7 дней | 100 запросов @ **50%** успех | 20 запросов @ **95%** успех | — |
| `reliability_score` | **0.911** (высокий из-за истории) | **0.910** | A выбирается! |
| Реальное качество | **50%** (деградировала!) | **95%** (отличная) | B лучше! |

**Последствия:**
- Система выбирает деградировавшую модель, игнорируя текущее качество
- Новые качественные модели не получают шанса из-за малой истории
- Пользователи получают ответы от нестабильных провайдеров

### 1.2 Решение

**Rolling Window** — учитывать только запросы за последние **7 дней** из таблицы `prompt_history`.

```python
# Новый расчёт
recent_success_rate = recent_successes / recent_requests  # за 7 дней
recent_reliability_score = (recent_success_rate × 0.6) + (recent_speed_score × 0.4)

# Fallback для новых моделей
if recent_requests < 3:
    effective_score = long_term_reliability_score  # старая формула
else:
    effective_score = recent_reliability_score     # актуальные данные
```

**Параметры:**
- **Окно:** 7 дней
- **Минимум запросов:** 3 (для статистической значимости)
- **Fallback:** если < 3 запросов за период → использовать long-term score

### 1.3 Целевая аудитория

| Сегмент | Описание | Потребности |
|---------|----------|-------------|
| Конечные пользователи | Пользователи Telegram-бота и Web UI | Получать ответы от наиболее стабильных AI-моделей |
| Администраторы | Операторы системы | Видеть актуальный рейтинг моделей |

### 1.4 Ценностное предложение

- **Актуальность:** Выбор модели основан на текущем качестве, а не исторических данных
- **Быстрая реакция:** Деградация модели отражается в рейтинге за дни, не месяцы
- **Справедливость:** Новые качественные модели быстрее поднимаются в рейтинге
- **Backward compatible:** Старая метрика сохраняется для отчётности

---

## 2. Функциональные требования

### 2.1 Core Features (Must Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-001 | Recent Stats Calculation | Data API рассчитывает статистику из `prompt_history` за последние N дней | SQL-запрос возвращает `{model_id: {success_count, request_count, avg_response_time}}` для всех моделей |
| FR-002 | Recent Reliability Score | Domain Model вычисляет `recent_reliability_score` по формуле `(recent_success_rate × 0.6) + (recent_speed_score × 0.4)` | Тест подтверждает корректность расчёта |
| FR-003 | Effective Score with Fallback | `effective_reliability_score` возвращает `recent_reliability_score` если запросов >= 3, иначе `reliability_score` | Тест проверяет fallback при недостаточных данных |
| FR-004 | API Parameter include_recent | `GET /api/v1/models` принимает `include_recent=true` для включения recent метрик в ответ | cURL запрос с параметром возвращает recent поля |
| FR-005 | Model Selection by Effective Score | Business API выбирает модель по `effective_reliability_score` вместо `reliability_score` | При деградации старой модели выбирается новая |

### 2.2 Important Features (Should Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-010 | Configurable Window | Параметр `window_days` в API (default: 7) | API принимает `window_days=3` и возвращает данные за 3 дня |
| FR-011 | Recent Metrics in Response | `AIModelResponse` включает `recent_success_rate`, `recent_request_count`, `effective_reliability_score` | Swagger показывает новые поля |
| FR-012 | Logging Selection Decision | Логировать почему выбрана модель (effective score, fallback) | Лог содержит `decision_reason: recent_score | fallback` |

### 2.3 Nice to Have (Could Have)

| ID | Название | Описание | Критерий приёмки |
|----|----------|----------|------------------|
| FR-020 | Configurable Min Requests | Параметр `min_requests` (default: 3) | API принимает `min_requests=5` |

---

## 3. User Stories

### US-001: Выбор модели по актуальным данным

**Как** пользователь Telegram-бота
**Я хочу** чтобы система выбирала AI-модель на основе её текущей надёжности
**Чтобы** получать ответы от наиболее стабильного провайдера

**Критерии приёмки:**
- [ ] Если модель A имела 99% успех год назад, но 50% за последнюю неделю — она НЕ выбирается
- [ ] Если модель B имеет 95% успех за последнюю неделю — она выбирается
- [ ] Выбор логируется с указанием причины

**Связанные требования:** FR-003, FR-005, FR-012

---

### US-002: Администратор видит актуальный рейтинг

**Как** администратор системы
**Я хочу** видеть и долгосрочную, и недавнюю статистику моделей
**Чтобы** понимать текущее состояние каждого провайдера

**Критерии приёмки:**
- [ ] API возвращает `reliability_score` (long-term) и `recent_reliability_score`
- [ ] API возвращает `recent_request_count` для понимания объёма данных
- [ ] Web UI показывает обе метрики

**Связанные требования:** FR-011, FR-004

---

## 4. Нефункциональные требования

### 4.1 Производительность

| ID | Метрика | Требование | Измерение |
|----|---------|------------|-----------|
| NF-001 | Время расчёта recent stats | < 100ms | SQL EXPLAIN ANALYZE |
| NF-002 | Влияние на выбор модели | + < 50ms к текущему времени | Prometheus metrics |

### 4.2 Совместимость

| ID | Требование | Описание |
|----|------------|----------|
| NF-010 | Backward Compatibility | Старое поле `reliability_score` сохраняется и работает |
| NF-011 | API Compatibility | Без `include_recent` API возвращает тот же ответ что и раньше |

### 4.3 Надёжность

| ID | Требование | Описание |
|----|------------|----------|
| NF-020 | Graceful Fallback | При ошибке SQL — использовать long-term score |
| NF-021 | Index Usage | SQL использует существующий индекс `ix_prompt_history_created_at` |

---

## 5. Технические ограничения

### 5.1 Обязательные технологии

- **Backend**: Python 3.11+, FastAPI
- **Database**: PostgreSQL 16 (существующая)
- **ORM**: SQLAlchemy 2.x (async)

### 5.2 Существующие ресурсы

| Ресурс | Описание | Готовность |
|--------|----------|------------|
| `prompt_history` table | Полная история запросов с `created_at` | ✅ Существует |
| `ix_prompt_history_created_at` | Индекс для временных запросов | ✅ Существует |
| `AIModel` domain model | Доменная модель с вычисляемыми свойствами | ✅ Нужно расширить |

### 5.3 Ограничения

- **Нет миграций БД** — используем существующую структуру `prompt_history`
- **HTTP-only архитектура** — Business API получает данные через Data API

---

## 6. Допущения и риски

### 6.1 Допущения

| # | Допущение | Влияние если неверно |
|---|-----------|---------------------|
| 1 | `prompt_history` содержит достаточно данных за 7 дней | Нужно увеличить окно или уменьшить min_requests |
| 2 | Индекс `created_at` достаточно эффективен | Возможно потребуется составной индекс |

### 6.2 Риски

| # | Риск | Вероятность | Влияние | Митигация |
|---|------|-------------|---------|-----------|
| 1 | Медленный SQL при большом объёме данных | Low | Medium | Использовать существующий индекс, LIMIT |
| 2 | "Cold start" для всех моделей при малом трафике | Medium | Low | Fallback на long-term score |

---

## 7. Открытые вопросы

| # | Вопрос | Статус | Решение |
|---|--------|--------|---------|
| 1 | Оптимальный размер окна? | Resolved | 7 дней (пользователь выбрал) |
| 2 | Минимум запросов для статистики? | Resolved | 3 запроса (пользователь выбрал) |

---

## 8. Глоссарий

| Термин | Определение |
|--------|-------------|
| Rolling Window | Скользящее окно — метод расчёта метрик только за последний период времени |
| Effective Score | Итоговый score для выбора модели (recent или fallback) |
| Fallback | Резервный механизм — использование long-term score при недостатке recent данных |

---

## 9. История изменений

| Версия | Дата | Автор | Изменения |
|--------|------|-------|-----------|
| 1.0 | 2026-01-02 | AI Analyst | Первоначальная версия |

---

## Качественные ворота

### PRD_READY Checklist

- [x] Все секции заполнены
- [x] Требования имеют уникальные ID (FR-*, NF-*)
- [x] Критерии приёмки определены для каждого требования
- [x] User stories связаны с требованиями
- [x] Нет блокирующих открытых вопросов
- [x] Риски идентифицированы и имеют план митигации
