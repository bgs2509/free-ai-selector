# ADR-0001: Reliability Scoring Formula

> Выбор формулы расчёта надёжности AI-моделей.

## Статус

**Accepted** (2025-01-17)

---

## Контекст

Free AI Selector должен автоматически выбирать лучшую AI-модель для обработки промптов. Необходимо определить критерии "лучшей" модели и формулу их комбинирования.

**Требования:**

1. Учитывать надёжность (успешность запросов)
2. Учитывать скорость ответа
3. Формула должна быть понятной и объяснимой
4. Значения должны быть нормализованы (0.0 - 1.0)

**Ограничения:**

- Бесплатные провайдеры имеют переменную доступность
- Скорость важна для UX, но не критична
- Некоторые провайдеры быстрые, но нестабильные

---

## Решение

Принята формула взвешенного среднего:

```
reliability_score = (success_rate × 0.6) + (speed_score × 0.4)
```

Где:

```python
# Success Rate (60% веса)
success_rate = success_count / request_count  # 0.0 - 1.0

# Speed Score (40% веса)
# Baseline: 10 секунд = score 0.0
average_response_time = total_response_time / request_count
speed_score = max(0.0, 1.0 - average_response_time / 10.0)  # 0.0 - 1.0
```

### Выбор весов

| Компонент | Вес | Обоснование |
|-----------|-----|-------------|
| Success Rate | 60% | Надёжность важнее скорости - пользователь предпочтёт медленный ответ, чем ошибку |
| Speed Score | 40% | Скорость важна для UX, но не критична |

### Baseline 10 секунд

10 секунд выбрано как разумный максимум ожидания AI-ответа:
- Меньше 2 сек → score > 0.8 (отличная скорость)
- 5 сек → score = 0.5 (приемлемо)
- 10+ сек → score = 0.0 (слишком медленно)

---

## Альтернативы

### Альтернатива 1: Только Success Rate

```python
reliability_score = success_rate
```

**Плюсы:**
- Простота
- Фокус на главном

**Минусы:**
- Не учитывает скорость
- Медленные модели получают высокий score

**Причина отклонения:** Игнорирование скорости ухудшает UX

### Альтернатива 2: Равные веса (50/50)

```python
reliability_score = (success_rate × 0.5) + (speed_score × 0.5)
```

**Плюсы:**
- Баланс метрик

**Минусы:**
- Быстрая, но нестабильная модель может обойти стабильную
- Не отражает приоритеты пользователей

**Причина отклонения:** Надёжность приоритетнее скорости

### Альтернатива 3: Мультипликативная формула

```python
reliability_score = success_rate × speed_score
```

**Плюсы:**
- Оба компонента обязательны

**Минусы:**
- Ноль в любом компоненте обнуляет score
- Новые модели (speed_score = 1.0, success_rate = 0) получают 0

**Причина отклонения:** Слишком агрессивное наказание новых моделей

### Альтернатива 4: Exponential Moving Average

```python
reliability_score = ema(success_rate) × 0.6 + ema(speed_score) × 0.4
```

**Плюсы:**
- Учитывает тренды
- Свежие данные важнее старых

**Минусы:**
- Сложнее реализация
- Сложнее объяснить

**Причина отклонения:** Over-engineering для текущего масштаба

---

## Последствия

### Положительные

- **Простота:** Формула легко объясняется и понимается
- **Объяснимость:** Можно показать пользователю почему выбрана модель
- **Гибкость:** Веса можно настроить без изменения архитектуры
- **Стабильность:** Надёжные модели получают приоритет

### Отрицательные

- **Базовые метрики:** Не учитывает качество ответов, только доставку
- **Холодный старт:** Новые модели имеют low score (0.4) пока не наберут статистику
- **Простое усреднение:** Не учитывает тренды и недавнюю производительность

### Риски

| Риск | Митигация |
|------|-----------|
| Модель "застрянет" с низким score | Health Worker регулярно тестирует все модели |
| Выбросы исказят статистику | Большой sample size сглаживает выбросы |
| Новые модели не получают шансов | Базовый score 0.4 даёт шанс на выбор |

---

## Примеры расчёта

### Идеальная модель

```
success: 100/100, avg_time: 2.0 sec
success_rate = 1.0
speed_score = 1.0 - 2.0/10.0 = 0.8
reliability_score = (1.0 × 0.6) + (0.8 × 0.4) = 0.92
```

### Быстрая, но нестабильная

```
success: 70/100, avg_time: 0.5 sec
success_rate = 0.7
speed_score = 1.0 - 0.5/10.0 = 0.95
reliability_score = (0.7 × 0.6) + (0.95 × 0.4) = 0.80
```

### Стабильная, но медленная

```
success: 95/100, avg_time: 6.0 sec
success_rate = 0.95
speed_score = 1.0 - 6.0/10.0 = 0.4
reliability_score = (0.95 × 0.6) + (0.4 × 0.4) = 0.73
```

---

## Ссылки

- [Reliability Formula](../project/reliability-formula.md) - Детальная документация
- [Database Schema](../project/database-schema.md) - Где хранится статистика
- [services/free-ai-selector-data-postgres-api/app/domain/models.py](../../services/free-ai-selector-data-postgres-api/app/domain/models.py) - Реализация
