# Инцидент: Docker build падал из-за DNS при активном VPN (Hiddify)

Дата: 2026-02-13  
Проект: `free-ai-selector`  
Контекст: локальная разработка на Ubuntu, запуск через `make up` / `docker compose up -d`

## 1. Краткое описание проблемы

При запуске `make up` сборка образов периодически зависала и завершалась ошибкой на шаге установки Python-зависимостей:

- `RUN pip install --no-cache-dir -r requirements.txt`

Падали минимум сервисы:

- `free-ai-selector-telegram-bot`
- `free-ai-selector-health-worker`

Симптом в логах выглядел как «пакет не найден», но это было следствием сетевой проблемы.

## 2. Симптомы и факты из логов

В `docker compose` логах фиксировались повторы:

- `Temporary failure in name resolution`
- `Retry(total=4..0) ... /simple/<package>/`
- `Could not find a version that satisfies the requirement ... (from versions: none)`
- `No matching distribution found ...`

Ключевой признак: ошибки резолвинга DNS внутри контейнера во время build-шага.

Дополнительно:

- `make: *** [Makefile:42: up] Error 1` — каскадное завершение `make`, так как `docker compose up -d` вернул non-zero код.
- Предупреждение `FromAsCasing` в Dockerfile не являлось причиной падения.

## 3. Диагностика (пошагово)

### 3.1 Проверка DNS, который выдал VPN

Команда:

```bash
resolvectl status tun0
```

Результат:

- `Current DNS Server: 172.19.0.2`
- `DNS Servers: 172.19.0.2`

Вывод: VPN-интерфейс `tun0` использует DNS `172.19.0.2`.

### 3.2 Проверка DNS в контейнере (bridge-сеть Docker)

Команды:

```bash
docker run --rm busybox nslookup pypi.org
docker run --rm busybox nslookup files.pythonhosted.org
```

Результат:

- `;; connection timed out; no servers could be reached`

Вывод: внутри контейнера DNS недоступен.

### 3.3 Проверка DNS через сеть хоста

Команда:

```bash
docker run --rm --network host busybox nslookup pypi.org 172.19.0.2
```

Результат: успешный ответ с IP-адресами `pypi.org`.

Вывод: DNS-сервер доступен с хоста, но недоступен из bridge-сетей Docker.

### 3.4 Проверка бэкенда firewall и подсетей Docker

Команды:

```bash
docker info | grep -i "Firewall"
docker network inspect $(docker network ls -q) --format '{{range .IPAM.Config}}{{.Subnet}}{{"\n"}}{{end}}' | sort -u
```

Изначально наблюдались подсети:

- `172.17.0.0/16`
- `172.18.0.0/16`
- `172.19.0.0/16`

При этом VPN DNS был `172.19.0.2`.

Вывод: пересечение адресного пространства (overlap) между Docker и VPN.

## 4. Первопричина

Первопричина — конфликт подсетей:

- Docker bridge использовал диапазон `172.19.0.0/16`.
- VPN DNS находился по адресу `172.19.0.2` (тот же диапазон).

Из-за пересечения маршрут к `172.19.0.2` из контейнера интерпретировался как локальный docker-сегмент, а не как DNS через VPN, что приводило к таймаутам DNS-запросов.

## 5. Принятое решение

Решение состояло из двух частей в `/etc/docker/daemon.json`:

1. Явно указать DNS с приоритетом VPN:
   - `172.19.0.2`, затем публичные fallback (`1.1.1.1`, `8.8.8.8`).
2. Увести Docker-сети из конфликтного диапазона:
   - `default-address-pools` с базой `10.66.0.0/16`.

Использованная конфигурация:

```json
{
    "userland-proxy": true,
    "iptables": true,
    "dns": ["172.19.0.2", "1.1.1.1", "8.8.8.8"],
    "default-address-pools": [
        { "base": "10.66.0.0/16", "size": 24 }
    ]
}
```

Применение:

```bash
sudo systemctl restart docker
```

## 6. Проверка после исправления

### 6.1 Проверка подсетей

После изменений подсети стали:

- `10.66.0.0/24`
- `10.66.1.0/24`
- `172.18.0.0/16` (legacy/существующая внешняя сеть)

Критично, что рабочие проектные bridge-сети ушли из `172.19.0.0/16`.

### 6.2 Проверка функциональности

- `make up` отработал успешно.
- Сборка сервисов перестала падать на `pip install`.

## 7. Почему это решение корректное

1. Устраняет первопричину (конфликт маршрутизации), а не только симптом.
2. Стабильно для повторных запусков и перезагрузки:
   - `daemon.json` читается Docker при каждом старте.
3. Не требует временных обходов вроде `build.network: host` для каждого сервиса.
4. Масштабируется на новые compose-проекты на этой машине.

## 8. Рассмотренные альтернативы

### Альтернатива A: `build.network: host`

Плюсы:

- Быстро помогает на build-этапе.

Минусы:

- Обходной путь, а не устранение корня проблемы.
- Требует правок compose для каждого сервиса/проекта.

### Альтернатива B: офлайн зависимости (`wheelhouse`)

Плюсы:

- Независимость от внешнего DNS/интернета на build.

Минусы:

- Операционный overhead (скачивание, хранение, обновление wheel-архива).
- Не решает общий DNS-конфликт для других сетевых операций.

### Альтернатива C: точечные iptables-правила на UDP/TCP 53

Плюсы:

- Можно открыть только DNS-трафик.

Минусы:

- Более хрупкая и сложная эксплуатация.
- При overlap подсетей может не снять проблему полностью.

## 9. Риски и что учитывать в будущем

1. Не добавлять Docker-пулы, пересекающиеся с VPN/корпоративными диапазонами.
2. При смене VPN-клиента проверять:
   - `resolvectl status <vpn_if>`
   - `docker network inspect ...`
3. Если снова появятся таймауты DNS:
   - сначала проверять пересечение подсетей, а не только список DNS-серверов.

## 10. Команды для быстрой самопроверки

```bash
# DNS VPN
resolvectl status tun0

# Подсети Docker
docker network inspect $(docker network ls -q) --format '{{range .IPAM.Config}}{{.Subnet}}{{"\n"}}{{end}}' | sort -u

# DNS из контейнера
docker run --rm busybox nslookup pypi.org

# Запуск проекта
make up
```

## 11. Краткий итог

Ошибка выглядела как проблема `pip`, но фактически была сетевой: DNS в Docker при VPN ломался из-за пересечения подсетей `172.19.0.0/16`.  
Перенос Docker address pool в `10.66.0.0/16` + явный DNS в `daemon.json` устранили причину и стабилизировали сборку.
